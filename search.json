[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/flaskHW/index.html",
    "href": "posts/flaskHW/index.html",
    "title": "Homework 3: Flask",
    "section": "",
    "text": "https://github.com/jakebrowning02/PICHHW3 https://jakebrowning02.github.io/PIC16BHW/posts/flaskHW/\nWe will start the tutorial with the init.py file. The first function we see in this file is create_app(). The function effectively the creation of the app. As we can see, in the first line, we will set the app to be an instance of the Flask class that we imported at the top of the page. Next we begin to configure the app by defining where the database is to be located, by mapping the database to the ‘flaskBlog.sqlite’ file. If you are wishing to use a different file name for your database, that is fine, but just be sure to use that file name here instead of the one that I used. It is important to note, that for this we must import os at the top of the page. The function os.path.join shows the computer how to reach the file we have specified. Continuing downward, we see a hello() function. This function is not critical to this project, but is useful in checking that the app is working correctly and also happens to be an easier wsay to explain how these functions work. Above the function we see the command ‘@app.route(’/hello’)’ which is critical to this function. This ties the url route ‘/hello’ to this function, a practice we will use pervasively throughout this project. This page simply prints out ‘Hello, World!’, but other pages will have more complex applications. The following commands are all imports that we will revisit later after we have defined the functions that they are referring to. Let’s move over to the db.py file. This file is responsible for defining most of the basic commands necessary for setting up our database. The first thing we want to do is to import sqlite3. This allows us to make an sqlite3 database on this page. We will also import click for a later function, but more importantly, we import both current_app and g from the flask library. g is a special object that is able to be accessed by multiple functions, which is also unique for each request. Similarly, current_app is another special object that points to the Flask application handling the request. We will ensure that current_app will be able to be used by importing this file into the other .py files. The first function we see is get_db(). We first want to check that there is no database currently in our special instance g. If there is not, logically we want to begin to access the database. We define the database connection by creating an attribute db of g, and setting it to sqlite3.connect(), effectively making it a cursor we can use to search the database in later functions. We then return this attribute so that when we import it into other files, we can effectively use this as our cursor. The next function close_db() is rather self explanatory. We need a way to close the connection to the database if the database is open. We check if it is open by writing the if statement ‘if db is not None:’. This way, we only attempt to close the connection if it exists, which we do within the if statement by calling db.close(). We now come across our function that is called when we are intiating the database, init_db(). Using the function we just defined, we call get_db() to create a cursor, and using that we open the schematic that we write for the database, defining the tables, rows, columns, and titles to be held within the database. The next function gives us a way to call the function we just created. We call @click.command(‘init-db’) so that we can call the function using a command line command. Now, when we call this function via the command, we can see that it simply calls the init_db() function and recieve a message letting us know that we have successfully initialized the database. Finally, we come to the init_app() function. This function will be used to ensure that the cursor is closed when it needs to be. In order to ensure that the cursor is closed each time after returning a response, we will use the function teardown_appcontext(). This calls whatever function is within the parentheses whenever a response is returned, so we choose to call close_db() whenever a response is returned. Finally, we want to travel back to init.py and look at what we imported from this page. By importing db.init_app(app), we allow ourselves to initiate the database within the init.py file. Let us now take a look at our last .py file, blog.py. This file will contain most of what we see on the web app. We will import several useful methods from flask up top to be able to run our code. Taking a look at the first function index(), we see it appears to have a similar formate to the hello() function we saw before. Using the @bp.route(‘/’), we define the URL extension to be the backslash to access this page. First thing we do in this function is define db to be the cursor we get from the get_db() function we created in the previous page. Now, we will use this cursor to access the database. We now select both the author and body attributes from every post in the database, and set this list to be the list posts. This will be used in the html to show all of the posts that are contained within our database. This is useful for debugging and being able to view the database in a user friendly manner. Now we reach the return line of this function by calling render_template() we tell the computer to run the html file template we have created for this page called ‘index.html’. In my case, this file is contained within a blog folder, hence the ‘/blog’ before the ‘index.html’. We also choose to pass the posts list to the template as it is used to display the posts on this page. Continuing on, we get to the function used to insert new messages into the database. We see the function is associated with the URL extension ‘/submit’, however this time we also define the methods(‘GET’, ‘POST’), as any user request will be considered a ‘POST’. We check to make sure that this is the case via the if statement at the beginning of the function. Now we need to get input from the user so that we can input their name and their message. We do so by using the request.form[] function, allowing us to use the input to define the variables. We then check that the boxes have been filled, and send an error if they have not been. If everything is working well, we then use the get_db() function to access the cursor again and use it to insert the new message with its author into the database. We ensure to call db.commit() to save the new information into the database and call for a redirect. This function sends us back to the main page by calling the index function in the blog.py file, or in other words the function above this one. We also make sure to render the template for this page so that the html file we write will appear on this page. The random_messages function again uses the cursor we acquire from get_db(). We then use a special command for the cursor ‘RANDOM()’ to select the rows from the database in a random order. We use the variable n to determine how many rows are to be selected, and then set this to the list messages to be returned by this function. The view function is associated with its own URL and is the page used to determine how many random posts the user withes to see. We use request.form.get() to take in the user input. Then again, assuming no errors, we call random_messages function with the user inputted amount of function and pass it to our final function randomview(). This final function is associated with its own URL and gets random messages from the random_messages function. We call int(request.args.get(‘num_messages’)) to get the amount of messages desired by the user, a value passed by the previous page. Finally, we will take a look at our template for the new post page. First, we extend ‘base.html’ so that we can keep what we coded in that. We now define our header under the {%block header%} and set the block title to ‘New Messages’. Next, we get to the block content. We create a label titled ‘Author’ which is used for our input. This title is placed with the input text box that sends its input to the value request.form[‘author’] which we use to input the value into the database. We then do the same for the message, however this time we define a textarea to create a bigger box for the user to input their message. Finally, we create a submit button that says ‘Submit message’ for the user to click after they input their desired information."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/HW4/index.html",
    "href": "posts/HW4/index.html",
    "title": "HW 4: Heat diffusion with Jax",
    "section": "",
    "text": "Comparison of methods\nWhen looking at the four methods that we have implemented, it is clear that the advance_time_matvecmul() method is by far the slowest at 1 minute and 39 seconds per loop while our final method, advance_time_jax() is the fastest at a mere 291 ms per loop. The method advance_time_numpy() and advance_time_jax() may seem relatively similar in speeds as there is less than a second separating their time to progress 2700 time steps, however in reality the jax method is a little less than twice as fast as the numpy method, at times of 291 ms and 520 ms respectively. That being said, they are both significantly faster than the sparse_advance_time_matvecmul() method at 1.7 seconds per loop , which itself is still much faster than the advance_time_matvecmul() which, as stated before, took approximately 1 minute and 39 seconds to advance our model through 2700 timesteps.\nWhen it comes to writing the functions, taking into account that I did not write the first method, I found the get_sparse_A() method the easiest to write, as I was simply building on the get_A() method I had previously written, and then writing one line to set my return value to a sparse matrix corresponding to the matrix returned by the get_A() function. Similarly, the get_A() function was relatively straightforward to write as I simply had to create a matrix and then edit three of the diagonals. I initially had some trouble when writing the advance_time_numpy() function as I was unsure of how to implement the boundary conditions that were to allow heat to escape from the model. Before successfully completing the boundary condition, my results yielded a heat map that began to take on an almost plus-like shape as the heat began to reach the edges and simply wrap around to the other side. I solved this problem by creating a matrix of dimensions (N+2)x(N+2), which allowed the heat to go to an outer ring that was effectively deleted before returning the function, simulating the idea that the heat escaped outside of our model. Similar to the get_A_sparse() function, after writing the advance_time_numpy() function the advance_time_jax() function was relatively easy to implement. Conceptually it follows the same pattern as the numpy function, with the only catch being that jax does not allow for index assignment. To get around this, I found a function .at(), helping me to navigate around the matrices, and more importantly, I created new matrices at each step, meaning I was not altering any pre-existing matrices, but rather creating new ones which is allowed by jax.\nBlog Tutorial\nToday we will create a simulation of two-dimensional heat diffusion using packages such as jax and numpy. Let us start by creating two jupyter notebooks, one titled heat_equation.ipynb, and the other jax_heat_map.ipynb. We will store our important methods in heat_equation.ipynb, while jax_heat_map.ipynb will be used to test them as we import them in.\nStarting in heat_equation.ipynb, let us start by importing the packages we plan on using in this project: jax, numpy, sparse from jax.experimental, jit from jax, and jax.numpy. I chose to import numpy as np and jax numpy as jnp to make them easier to use as we will be using them a fair amount. We are now ready to begin implementing our first method advance_time_matvecmul(). For this function we will take in three arguments, A, u, and epsilon. It is important to familiarize ourselves with what these variables represent in the model as they will be used pervasively throughout the process. The value A represents the transition matrix to be used. The variable u represents an N x N matrix that is the current state of our heat map. We will find soon that initially u, at time zero called u0, is a simple point in the middle of the matrix. In order to update to the next timestep, we will use A, which is a numpy array of size N2 x N2. By finding the product of A and u, we find what kind of change is to be seen when moving to the next timestep. Finally, epsilon tells us the magnitude of that change. Therefore, the change we see between timesteps is given by the epsilon(Au). Finally, to get to the next timestep, we simply add the change to our current state, u, to the change we just found, setting this all equal to a new u to get to our next time step.\nNow that we understand the math behind what we are trying to simulate, we can get back to our advance_time_matvecmul() function in heat_equation.ipynb, which is passed in the three parameters u, A, and epsilon. The purpose of this function is to simply advance us one timestep in the simulation, returning the value u representing the new heat map. Luckily, we know how to do that given our discussion in the previous paragraph. By simply using the equation we found, we can set u equal to u + epsilon(Au), however there are some technicalities that we need to deal with. Firstly, we need to use the u.flatten() function when finding the product of A and u as otherwise we will encounter an error due to differences in dimensions between A and u. When flattened, u becomes a one dimensional array of size N2, allowing for the product to be calculated by multiplying by an N2 x N2 matrix, namely A. Unfortunately, to return a reasonable u, we need a matrix that is of the dimensions N x N, similar to the u we were passed in. To get our flattened product of A and u back into the form of an N x N matrix we can use the .reshape(A,B) function which will revert the product back into an A X B matrix. It seems that we could simply replace A and B in this function with N and N as we know those are the dimensions of our desired matrix, however we must be careful here as there was no value N passed into this function. While a global N may have been declared, it is safer to use the shape of u passed in to calculate our dimensions. To find these dimensions, we use the .shape attribute of u, calling u.shape[0] to find the dimension of the first axis, which corresponds to the N that the passed in u is utilizing. You may notice that I used u.shape[0] for both parameters, yielding reshape((u.shape[0],u.shape[0])) instead of using the u.shape[1] for the second parameter. This works only because we know that u is square, and therefore u.shape[0] and u.shape[1] will yield the same value. Therefore, there is no harm using the first index for the second parameter, however I simply chose to use the zeroth index for both. We have now successfully implemented the Au part of our equation into the function, and the next part is quite simple. As epsilon is simply a scalar, we can directly multiply the matrix that we just found by epsilon, yielding the epsilon(Au) part of the equation that we said represented the total change going from one timestep to the next. To get the actual new u for the new timestep, we can add it all to the initial u we received to get our new u. Note that we are only able to add these two values together because they are matrices of the same dimensions. Finally, we can set this whole value equal to our return value, which I also named u, and return this value.\n\nimport inspect\n%run heat_equations.ipynb\nprint(inspect.getsource(advance_time_matvecmul))\n\ndef advance_time_matvecmul(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix\n        u: N x N grid state at timestep k\n        epsilon: stability constant\n\n    Returns:\n        N x N Grid state at timestep k+1\n    \"\"\"\n    \n    #update our u to the next time step using matrix multiplication\n    u = u + epsilon * (A @ u.flatten()).reshape((u.shape[0], u.shape[0]))\n    return u\n\n\n\nFirst function is officially finished! Now looking at the parameters, we can see that epsilon will be easy to find as it is just a scalar value, u will be a bit trickier, but in the beginning it is mostly zeros, making it easier to define. On the other hand, A is a little bit trickier to create. The good news is that A does not change throughout our computations, so we just need to define it once before we start computations. We know that A is a matrix of size N2 x N2, so we can start by defining a value n to be N2 as this will be useful for the coming commands. We then create a list of numpy arrays called diagonal, of different lengths varying from n to n-N, which are all filled with ones with the exception of the first being filled with (-4). These will be used to define the diagonals in our matrix that need to be filled with 1, -1, or -4. We then call the first and third index of our list diagonals, and set ____ to equal zero. Finally, we use these diagonals to create our matrix A, which is mostly zeros with the exception of the diagonals that we had defined earlier. We then return this matrix A, concluding the implementation of this function.\n\nprint(inspect.getsource(get_A))\n\ndef get_A(N):\n    '''Defines our transition operator A given value N\n    Args:\n        N: Size of our vector u0 to be used.\n    Returns:\n        A: The NxN transition matrix that would be used for \n        a vector of size N\n    '''\n    \n    #define n to be N*N to be used as length of A\n    n = N * N\n    #Setting the diagonals to be -4 and 1 where necessary\n    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\n    #setting all other values to zero\n    diagonals[1][(N-1)::N] = 0\n    diagonals[2][(N-1)::N] = 0\n    #combining diagonals to create matrix A\n    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n    return A\n\n\n\nWe are now ready to check if the functions we just wrote are functioning properly! Let us go to the other file we created, jax_heat_map.ipynb, and do some setup with some more imports. For this file I imported all of the files we imported for the heat_equation.ipynb as well as importing time and pyplot from matplotlib as plt. The time package will be used to test how efficient our functions are, while the pyplot package will be used to visualize our data to ensure that we are achieving reasonable results. Next we want to ensure that we can use the function we wrote in our other file, so we can run the command %run heat_equation.ipynb. This will run the file we wrote first, allowing this new file to access all of the functions defined in the previous file heat_equations.ipynb. Next, we can decide on the values of the parameters we will use for our model. I set my epsilon to 0.2 and my N to 101 for a reasonable estimation of diffusion. Next, let us get a matrix A we can use by calling our function get_A() while passing the variable N as an argument. Finally before testing, we will create an empty list called listShow. This list is where we will store some of the information at certain time steps to get a peek into how our function is performing. Now, before we call our function, we must define an initial u0 as our starting point for our heat. A good starting point is putting one unit of heat at the midpoint. To accomplish this, we first define u to be an NxN matrix full of zeros using the command np.zeros((N,N)). To find the middle, we simply use the index u0[int(N/2),int(N/2)] and set it equal to 1.0. If we want to see how it looks, we can run the command plt.imshow(u0) and you should see a dark grid with one small, bright square in the middle. Now that we have defined all of our parameters, we are ready to start. Running the function just once will produce very minimal changes in our grid, so it is advantageous to run the model many times and check in on the results at regularly scheduled intervals. This sounds like the perfect place to implement a for loop. Let us run a variable, call it i, in range from (1, 2701), setting u0 equal to the function call of advance_time_matvecmul(A,u0,epsilon). This will run to timestep 2700, yielding enough time to see significant results. However we mentioned that we wanted to be able to check in on the progress at regularly scheduled intervals, say every 300 timesteps. To implement this, within the for loop we can write an if statement checking if i%300==0, which would imply that i is a multiple of 300. Then, within the if statement we can append both u0 and i in a list to the empty list we created just before writing this loop, listShow. I also like to print out i every time it hits a multiple of 300, to make it easier to keep track of the progress of the loop. We can now run our first iteration of our model, however note that this code block will take a long time to run. For my machine it took about a minute and a half to run. If you desire, you can time how long it takes on yours by inserting the command %%time it -r 1 -n 1 at the top of the block. This will print out how long the block of code took to run when the block is done running. While your code is running, you should be able to see a new multiple of 300 be printed out every once in a while as the variable i iterates past that value in the loop, which is a good way to keep track of the progress through the loop.\n%%timeit -r 1 -n 1\n#setting u0 to initial condition\nu0 = np.zeros((N,N))\nu0[int(N/2), int(N/2)] = 1.0\n#using for loop to update our timestep 2700 times\nfor i in range(1, 2701):\n    #calling function to advance forward one timestep\n    u0 = advance_time_matvecmul(A, u0, epsilon)\n    if i%300 == 0:\n        #appending state every 300 steps and printing timestep for debugging\n        listShow.append([u0,i])\n        print(i)\nOutput:\n\nOur loop has finally finished running! The only issue is we do not see any results outside of the increments of 300 printed out to the screen and the excruciatingly long time it took to run that block of code, 1 minute and 39 seconds for me. Therefore, our next step is to visualize the steps our model just underwent. We remember that we stored the status of u0 at each increment of 300 in listShow. Doing some quick math we can calculate that we have nine total updates stored in this list, which we will use pyplot to display in a nice fashion. As we have nine instances, it seems reasonable to present them in a 3 x 3 grid, so let us set a variable rows and columns both equal to three. Next we are going to define a variable that will not be used until a bit later, call it img_count and set it equal to zero. We are now ready to define our display figure using pyplot by calling plt.sublots(nrows=rows, ncols=cols, figsize=(15,15)). The parameters we are passing into this function are relatively self explanatory, nrows refers to the number of rows desired, ncols refers to the number of columns desired, and figsize is how large we want the figure to be. We can set this equal to fig, axes as these will be the variables we access when plugging our information into the new grid. Finally, we can run a nested for loop to access each element of our new 3 x 3 grid. While running i in range of rows and within that j in range of columns, we call axes[i,j].imshow(listShow1[img_count][0]). This displays the image created by our stored u value in listShow in the axes indexed at [i,j]. We can see that img_count makes its long awaited appearance here, as it serves as our iterator through the list, meaning it is critical to increment it by one next to ensure that we do not print the same picture in each portion of the grid. You should see an output of a 3 x 3 grid, and in each slot there is a dark square, with a circle of light in the middle, growing bigger each time as we go from top left to bottom right. Conceptually, this makes sense as the light represents the heat diffusing throughout the square area as time passes. If you see a similar result, then we know that our first two functions are working as intended.\n#setting dimensions of image display\nrows=3\ncols = 3\n#defining variable to be used in display loop\nimg_count = 0\n#defining our display figure\nfig, axes = plt.subplots(nrows=rows, ncols=cols, figsize=(15,15))\n#looping through each element in our figure, setting each to a different timestep of our model saved in list listShow\nfor i in range(rows):\n    for j in range(cols):        \n        if img_count &lt; len(listShow):\n            #setting each box in display equal to unique image from list\n            axes[i, j].imshow(listShow[img_count][0])\n            #incrementing img_count to let us traverse along the list\n            img_count+=1\n\nNow that our first two functions are up and running, we can start working on our next function, get_sparse_A(). The purpose of this function is simply to take in a dimension N and return the sparse version of the A matrix corresponding to the N. Luckily, we have already done half of the work in our previous function get_A(), which we can call directly while passing it the parameter N. This will create the A matrix that we intend to convert into a sparse matrix. The jax package holds an experimental sparse matrix support that we will be using for this purpose. The exact format we will use is called the batch coordinate (BCOO) format, which will allow us to use less space to store this matrix, which will in turn drastically decrease the time required for the matrix multiplication. In order to convert this A matrix into its sparse form, we run the command sparse.BCOO.fromdense(A). We call sparse as it is part of the sparse package, BCOO is the format in which we wish to convert the matrix to, and fromdense signifies that we wish to go from a normal or ‘dense’ matrix, to a sparse matrix. Now we assign that to our return value A_sp_matrix, and return that value, completing the purpose of this function.\n\nprint(inspect.getsource(get_sparse_A))\n\ndef get_sparse_A(N):\n    '''Returns a sparse form of our transition matrix A\n    Args:\n        N: Size of our vector u0 to be used\n    Returns:\n        A_sp_matrix: The sparse form of the NxN transition matrix \n        that would be used for a vector of size N \n    '''\n    \n    #get the matrix A corressponding to the passed value N\n    A = get_A(N)\n    #find sparse version of matrix A and set it to our return value \n    A_sp_matrix = sparse.BCOO.fromdense(A)\n    return A_sp_matrix\n\n\n\nWe now want to double check that this function is running properly, so we will traverse back to jax_heat_map.ipynb to run a similar chunk of code that we ran previously, with a few key differences. First, instead of passing A to our advance_time_matvecmul() function, we want to ensure it is able to handle a sparse matrix in the hopes that it will decrease the time needed for computations. In order to get such a sparse matrix, we call our new function get_sparse_A(), while passing N as an argument. I set this equal to a variable named sp_A so that I knew this was the sparse version of my A matrix. Then, I initialized a new list called listShow1, setting it equal to an empty list. Next, we want to do the same process we did to check our first two functions, except this time we will pass in sp_A to advance_time_matvecmul() as well as applying the jit function to it. The jit function will use the jax just in time compilation feature which will drastically improve the performance of the function. When running this code block, we can see how much this improves the speed, taking the block 1.7 seconds to finish as opposed to over a minute for the previous attempt. Again using a similar process to above, we will display our data in the exact same way, except we will be getting our display information from listShow1 instead of listShow. Our output should be similar to the output we got previously.\n%%timeit -r 1 -n 1\n#resetting u0 to initial condition\nu0 = np.zeros((N,N))\nu0[int(N/2), int(N/2)] = 1.0\n#looping to increase timestep a total of 2700 times\nfor t in range(1, 2701):\n    #calling jitted version of function to advance timestep\n    #note that the matrix passed in is a sparse matrix\n    u0 = jit(advance_time_matvecmul)(sp_A, u0, epsilon)\n    if t%300 == 0:\n        #appending timestep information once every 300 steps, printing for debugging purposes\n        print(t)\n        listShow1.append([u0,t])\nOutput:\n\n#defining dimensions of our display figure\nrows=3\ncols = 3\n#resetting variable to be used in display loop\nimg_count = 0\n#defining our display figure\nfig, axes = plt.subplots(nrows=rows, ncols=cols, figsize=(15,15))\n#looping through each element in our figure, setting each to a different timestep of our model, saved in list listShow1\nfor i in range(rows):\n    for j in range(cols):        \n        if img_count &lt; len(listShow1):\n            #sets each box in display to different image in listShow1\n            axes[i, j].imshow(listShow1[img_count][0])\n            #increment img_count to traverse along the list\n            img_count+=1\n\nWe are now prepared to implement another method, providing us with an alternate way to run our model without using matrix multiplication. Instead, we will use vectorized array operations to progress our model, made possible by the numpy passage. We have the equation that the update discrete update time is:\n\nTherefore we need to find a way to update each point so as to abide by this equation. For me it helped to visualize it in two separate updates, a vertical and horizontal one. Looking at the horizontal changes, we see that for each value in the matrix at time t+1, is created in part by adding the elements directly to the left and right from the matrix at time t. As you may be considering already, we run into an issue with the values at the borders in which there is no value to either the right or the left. To deal with this, we will create an array of zeros of size (N+2)x(N+2), and place our current grid state at time u into the middle of the matrix. This will give us a bit of leeway in our computations as these outer values will not affect the inner values as they are zeroes and it does not matter computationally what happens to them does not matter as we will get rid of them before returning our updated grid state u_new. Starting from the beginning, we have to get what value to use for N as we are only passed in u and epsilon. To do this we will again extract N using the shape of the grid state u passed into the function, accomplished by setting m,N to u.shape. Now that we have acquired our value for N, we can define our (N+2)x(N+2) matrix full of zeros by again using the function np.zeros((N+2,N+2)). To set the middle to be equal to u, we use indexing and set the middle region, indexed by [1:-1,1:-1], equal to the grid state u. Now that we have our matrix u with a surrounding padding of zeros, we can begin our calculations. We first will find our changes in the x-direction using the update equation stated earlier and numpy’s .roll() method. The .roll() method rolls each element along a given axis, with values rolling past the last position being sent back to the first position. We can use this to define the change between each iteration. It helped me to split it into two changes, one along the x-axis and the other along the y-axis. Looking at the x-axis, for each updated element we need to add the element directly to the left and right of it, which we can accomplish by using an np.roll() both left and right. We do this by setting the axis equal to zero, as that corresponds to the x-axis, and first setting the shift to one, as that moves us one element to the right. Next, we call np.roll() again and set the shift to -1, representing a shift to the left. Now we can do the same thing for the y-axis, the only difference being we are setting the axis in our roll functions equal to 1 as that corresponds to the y-axis. Now we have taken care of almost all of the changes found in our discrete time equation, but we are missing the 4u term. To account for this, I simply subtracted 2u from each equation to combine for a total of (-4u), however you could do this at a later stage if desired. Now that we have determined what the change is to be between timepoints, we multiply by epsilon and add the u passed into the function as we did in our previous advance_time_matvecmul() function, setting it equal to a matrix named finU. We may be tempted to stop here, however we are missing a key factor: the matrix we have created remains a (N+2)x(N+2) matrix, when we want to return a matrix of size N x N. Luckily, we have set it up so that the outer ring of values are to be thrown away, as we initially introduced them within the function. To accomplish this, we set our return matrix, u_new, equal to the center portion of finU using the indices[1:-1,1:-1] before returning this new matrix.\n\nprint(inspect.getsource(advance_time_numpy))\n\ndef advance_time_numpy(u, epsilon):\n    \"\"\"Advances simulation by one timestep using functions from numpy\n    Args:\n        u: NxN grid state at timestep k\n        epsilon: stability constant\n        \n    Returns: N x N Grid state at timestep k+1\n    \"\"\"\n    #get N so we know the size of matrix we are working with \n    m,N = u.shape\n    #create new matrix of size with two extra rows and columns\n    newU = np.zeros((N+2,N+2,),dtype='float64')\n    #set the center of new matrix equal to u, meaning ring of zeros around passed matrix u\n    newU[1:-1,1:-1] = u\n    #implement changes in x direction\n    u_xx = np.roll(newU, shift=1, axis=0) - 2 * newU + np.roll(newU, shift=-1, axis=0)\n    #implement changes in y direction\n    u_yy = np.roll(newU, shift=1, axis=1) - 2 * newU + np.roll(newU, shift=-1, axis=1)\n    #apply changes and set it equal to a new matrix\n    finU = newU + epsilon * (u_xx + u_yy)\n    #eliminate outer ring of values, allowing the heat to escape, setting equal to return value\n    u_new = finU[1:-1,1:-1]\n    return u_new\n\n\n\nTo check that this function is running correctly, we can repeat the same debugging process we have done twice now in jax_heat_map.ipynb: create a new empty list, and run our loops. However this time, we will call the new function advance_time_numpy() and only pass the parameters u and epsilon as this function only takes these two parameters. You should notice another increase in speed as mine took 520 ms to run the code. Again, the output should appear very similar if not identical to the outputs from our previous attempts using the other functions. Note, the function advance_time_numpy() is not to be jitted as advance_time_matvecmul() was.\n%%timeit -r 1 -n 1\n#resetting u0 to initial conditions\nu0 = np.zeros((N,N))\nu0[int(N/2), int(N/2)] = 1.0\n#looping to increase timestep a total of 2700 times \nfor t in range(1, 2701):\n    #calling numpy function to advance timestep\n    u0 = advance_time_numpy(u0, epsilon)\n    if t%300==0:\n        #appending timestate information once every 300 steps, printing for debugging purposes\n        newList.append([u0,t])\n        print(t)\nOutput:\n\n#setting the dimensions for our display figure\nrows=3\ncols = 3\n#resetting variable used in display loop\nimg_count = 0\n#defining our display figure\nfig, axes = plt.subplots(nrows=rows, ncols=cols, figsize=(8,8))\n#looping to fill our display figure\nfor i in range(rows):\n    for j in range(cols):        \n        if img_count &lt; len(newList):\n            #setting each box in display equal to unique image from list newList\n            axes[i, j].imshow(newList[img_count][0])\n            #incrementing img_count to traverse to next list element\n            img_count+=1\n\nFinally, we have come to our last function, advance_time_jax(). In this function, we wish to implement a similar method to advance_time_numpy(), however as we plan to jit this function, we have to be careful in how we do so. Much of the setup is the same as the numpy function as we will use u.shape() to get our value for N and will then create a new matrix of size (N+2)x(N+2) full of zeros called newU. We again wish to fill the middle of this matrix with the matrix that we were passed in, however we cannot change individual indices due to restrictions for jax, therefore we will be creating lots of new matrices. Therefore, instead of directly reassigning values for the central section of our matrix newU, we will use the .add function to add u to just our central section by calling the function .at[1:-1,1:-1], effectively placing u in the middle as we are simply adding u to a bunch of zeros. After assigning this altered matrix back to newU, we can do the same process as we did in numpy to define our changes in the x and y directions, however instead of calling np.roll(), we will be calling jnp.roll() to call the jax version of numpy. We can then apply the changes, assigning it to a new matrix finU, in the same way as we did in numpy as finU = newU + epsilon*(u_xx+u_yy). Now, we can select just the center values, setting it equal to the new matrix we will be returning, u_new, and we are finished with our final method.\n\nprint(inspect.getsource(advance_time_jax))\n\ndef advance_time_jax(u, epsilon):\n    \"\"\"Advances simulation by one timestep using jax without using\n        matrix multiplication routines.\n    Args:\n        u: N x N grid state at timestep k\n        epsilon: stability constant\n        \n    Returns: N x N Grid state at timestep k+1\n    \"\"\"\n    #get N so that we know what size of matrix we are working with\n    m,N = u.shape\n    #create new matrix with two extra rows and columns\n    newU = jnp.zeros((N+2,N+2))\n    #set the center of the new matrix equal to the passed matrix u\n    newU = newU.at[1:-1,1:-1].add(u)\n    #define the changes to be implemented in the x direction\n    u_xx = jnp.roll(newU, shift=1, axis=0) - 2 * newU + jnp.roll(newU, shift=-1, axis=0)\n    #define the changes to be implemented in the y direction\n    u_yy = jnp.roll(newU, shift=1, axis=1) - 2 * newU + jnp.roll(newU, shift=-1, axis=1)\n    #implement the changes into a new matrix\n    finU = newU + epsilon * (u_xx + u_yy)\n    #setting the return value to the matrix with only desired values\n    u_new = finU[1:-1,1:-1]\n\n    return u_new\n\n\n\nTo check that we have created another functioning method, we repeat the same debugging process as we did for advance_time_numpy(), except we create a different list and call the advance_time_jax() function while making sure to jit the function as we call it. This function should be very fast, even faster than our previous function, as mine took 291 ms to run the code. If the output appears identical to our previous iterations then we have completed all of our methods successfully.\n%%timeit -r 1 -n 1\n#resetting u0 to initial conditions\nu0 = np.zeros((N,N))\nu0[int(N/2), int(N/2)] = 1.0\n#looping to increase timestep a total of 2700 times\nfor t in range(1, 2701):\n    #using jax function to advance timestep by one\n    u0 = jit(advance_time_jax)(u0, epsilon)\n    if t%300 == 0:\n        #once every 300 steps append timestep information to list, printing step for debugging purposes\n        newList1.append([u0,t])\n        print(t)\nOutput:\n\n#defining dimensions of display\nrows=3\ncols = 3\n#resetting variable used in display loop\nimg_count = 0\n#defining our figure\nfig, axes = plt.subplots(nrows=rows, ncols=cols, figsize=(8,8))\nfor i in range(rows):\n    for j in range(cols):        \n        if img_count &lt; len(newList1):\n            #filling each box with image from information in newList1\n            axes[i, j].imshow(newList1[img_count][0])\n            #incrementing to allow for traversal along list\n            img_count+=1"
  },
  {
    "objectID": "posts/bruinPage/index.html",
    "href": "posts/bruinPage/index.html",
    "title": "Analysis and Recommendations of Web Scraped Movie Data",
    "section": "",
    "text": "In this blog post, I’m going to create a web scraper that will allow us to recommend new movies based on shared actors with your favorite movie.\nThe first thing we are going to do is navigate to the website called TMDB, found at the URL https://www.themoviedb.org/ . We can now pick our favorite movie that will be the basis of our recommendations, mine is Harry Potter and the Philosopher’s Stone. Next, I navigated to the main movie page found at: https://www.themoviedb.org/movie/671-harry-potter-and-the-philosopher-s-stone This URL is important to save for later as it will be the starting point for our spider. Now we can start to create our spider. The first step is to type the following into the terminal:\nconda activate PIC16B-24W\nscrapy startproject TMDB_scraper\ncd TMDB_scraper\nThis command will activate the PIC16B-24W environment that we installed previously, create a scrapy project with the name TMDB_scraper on your computer, and then change the directory of your terminal to your newly created project. As we navigate to the TMDB_scraper folder, we see that there are various files within the project, however first we want to navigate to the file titled ‘settings.py’, and add the following line:\n    CLOSESPIDER_PAGECOUNT = 20\nThis will limit the number of pages our spider will visit initially, limiting the amount of data it will acquire when we are constructing and debugging. Additionally, I wrote the line:\nUSER_AGENT = ‘Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148’\nThis line helps to minimize the chance that the website identifies your spider as a bot and tries to block the web scraping process. Finally, it is time to begin writing our spider. Inside of our project folder, navigate into the spiders directory and create a new file titled ‘tmdb_spider.py’, and add the following chunk of code to the file:\nimport scrapy\nclass TmdbSpider(scrapy.Spider):\n\n    name = 'tmdb_spider'\n    \n    def __init__(self, subdir=None, *args, **kwargs):\n    \n        self.start_urls = [f\"https://www.themoviedb.org/movie/{subdir}/\"]\nThis code chunk will allow us to run the spider for our movie of choice from the terminal by giving the subdirectory on the TMDB website as our extra argument. Now that we have a working spider, it is time to implement our three parsing methods: parse(self, response), parse_full_credits(self, response), and parse_actor_page(self, response).\nLet’s start with the parse(self, response) function. The role of this function is to navigate from our main movie page to the ‘Full Cast and Crew’ page. If we go back to our main movie page, and navigate to the ‘Full Cast and Crew’ page, we can see that the only change in our URL is there is now a ‘/cast’ at the end. That tells us, all we need to do to get to our cast page is to add ‘/cast’ to the end of our current URL, and send our spider to the page found by our new URL. As we can see in the function below, we define our new URL to be called ‘full_credits_url’ which is created by taking ‘response.url’, the URL of the page we’re on, and adding the string ‘/cast’ to the end. As we now have the URL for the page we want to navigate to, we yield a scrapy.Request to send our spider to the cast page, passing our new ‘full_credits_url’ as the URL parameter, and setting the callback to the parse_full_credits() function as we will now navigate to the full credits page.\ndef parse(self, response):\n\n        '''\n        This function takes us from the main movie page to the cast and credits page yielding the url of the full credit page to be parsed by the parse_full_credits\n        '''\n        \n        #modifies url in order to navigate to the cast page\n        \n        full_credits_url = response.url + '/cast'\n        \n        #sends spider to the full credit page\n        \n        yield scrapy.Request(url=full_credits_url, callback=self.parse_full_credits)\nNow that we have made it onto the full cast and credits page, we will work with the parse_full_credits(self, response) function that was called as we navigated to this page. The goal of this function is to find all the actors who played a role in the movie and send our spider to their individual pages to be parsed by our final function parse_actor_page(). Last time we were able to navigate to the cast page by simply adding ‘/cast’, however as each actor has their own distinct name and page, we will not be able to hardcode the new URL. In fact if you click on the first actor or actress in the list, in my case Daniel Radcliffe, we see that the URL for their individual page contains a seemingly arbitrary number followed by their name. In order to find the extension for each actor, let us navigate back to the full cast and credits page. By right clicking on the top actor or actress’s name, followed by clicking inspect, we can see where their name is stored in the HTML file. More importantly, just before where their name is stored in text, we see something similar to ‘ Daniel Radcliffe’. Should we navigate back to Mr. Radcliffe’s page, we can see that the the element defined as ‘href’ is the same as the URL extension for the page, after the ‘https://www.themoviedb.org/’ that all pages on the TMDB site begin with. Clearly this is critical information as it will allow us to navigate to the actor or actress’s page using their URL extension. Now, we simply need to find a way to access this information for all of the actors. As we go back to the cast and credits page and look at the line where the first name was stored, we can traverse backwards to the line starting with “&lt;li data-order=”0” data-credit-id=” and then up again to the line reading ‘&lt;ol class = “people credits”&gt;’. It is important to note the information of all the cast members, including their names and the ‘href’ URL extensions we are trying to extract are all located under this ol class. We want to access this class from the HTML file in order to use it in our function, which we will be able to accomplish using css selectors. By taking a look at the first line of code, we can see that in the selector, we start in the overarching ol class, before specifying to travel down through the li class and finally asking for the attribute ‘href’ located within a. One thing to note about this line is the ‘:not(.crew)’ following the ol class. This effectively tells the program that all we do not want the attributes of any of the crew members, but only the attributes of the actors. Additionally, the .extract() command at the end of the line effectively gathers the information from the location we specified in the selector, allowing us to assign it to our variable actor_selectors. This command returns a list of the URL extensions for every actor in the movie and stores it in the actor_selectors variable. Now that we have the URL extensions, we can finish this function in a similar manner to the initial parse() function by creating new URLs for the spider to follow. As we observed before, every actor page starts with ‘https://www.themoviedb.org/’, and is followed by a tail unique to each actor which we have stored in the actor_selectors list. Now, to send our spider to each actor page, we simply write a for loop that iterates through all of the actor extensions in our actor_selectors list, add the extension to the generic URL started mentioned above, and again send the spider to the new page addressed by our new URL saved as actor_page_url. Our yield scrapy.Request() is slightly different than the one we used in the previous function as instead of calling parse_full_credits(), we are going to call parse_actor_page() as the spider is now traveling to an individual actor page.\n def parse_full_credits(self, response):\n \n        '''\n        This function navigates from the response's full credits page to each actor's individual page to be parsed in the parse_actor_page() function.\n        '''\n        \n        #creates list of cast members, excluding the crew members\n        \n        actor_selectors = response.css('ol.people.credits:not(.crew) li div.info a::attr(href)').extract()\n        \n        #for loop iterates over actor list sending spider to each actor page\n        \n        for actor_ in actor_selectors:\n        \n            actor_page_url = 'https://www.themoviedb.org'+actor_\n            \n            yield scrapy.Request(url=actor_page_url, callback=self.parse_actor_page)\nWe have now reached our third and final parsing function, parse_actor_page(self, response). The goal of this function is to identify all the movies in which the individual played an acting role and yield dictionaries that contain the individual’s name with the title of the movie they played a role in. The first thing we must do is identify the name of the actor or actress whose page we are on. This will be a similar process to finding the actor page references in the previous function, however this time there is only one piece of data we wish to extract, making it even simpler. Let us continue with our Daniel Radcliffe example from earlier by navigating back to his actor page. By highlighting his name at the top of the page and then clicking on the inspect option, we can again see where his name is stored in the HTML file associated with this page. We can see it is located as an attribute under a class titled ‘h2 class=”title”&gt;’ which we will again be able to access via css selectors. As we can see from the first line of code below, in the css selector we start at the h2 title class and then traverse to the ‘a’ section in which the name is located. Different from last time, we add the command ‘::text’ afterwards to tell the program we want the text stored at this location as opposed to the href attribute which is what we were looking for in the previous function. It is also important to note that here we are using .extract_first() instead of .extract() as we want the name itself as a string instead of a list containing the name, which is accomplished by .extract_first() which extracts the first element of the list to be returned while .extract() would grab the entire list. The .strip() at the end of the line simply ensures that there is no whitespace before or after the name to keep everything neat and consistent. We now have the name of the individual who the page belongs to stored under the variable actor_name, meaning that now we only need to find the names of the movies in which they played an acting role. We will now again implement a similar method to extract the titles of the movies the actor played a role in. If we highlight the title of the first movie or show under the ‘Acting’ section and check where it is located in the HTML file, we find it is under one of many sections labeled ’\n\n’ which are all under a table class titled ‘credits list’. While we could try and simply use the css selectors to try and locate this class as before, we must notice that there are two other classes with the same title, which would clearly make it somewhat tricky for the program to decipher exactly which one we are trying to access. Taking a closer look at these three classes, we can observe an h3 line above each one which are identical except for one word in each, the different words being ‘Acting’, ‘Production’, and ‘Crew’. Clearly we want to access the one referring to the acting roles, as we are not concerned with production and crew roles, however we need to find a way to access the correct table under acting. By taking another glance at the HTML file, we can see that the three classes of interest are all located within a div class titled ‘credits_list’. We can take advantage of this by creating a list of all the h3 terms under this list via the command defining datCred. Now that we have the list, we can simply search for which h3 contains the word ‘Acting’ to find exactly which table we want by using a for loop to iterate through each h3 element in datCred. We check for acting by checking if ‘Acting’ is in the text of the h3 element, as found in the condition of the if statement within the for loop. Now that we have identified which h3 term we want to follow, we will take advantage of xpath, another kind of selector, which has a useful function called ‘following-sibling’. This specifier tells the selector to follow a sibling class, a class with the same parent and on the same level as the initially specified node, and we have then included the xpath to ‘table[1]’ in which the tr classes containing the movie names are located, saving it to the variable txt. We then use the Selector() function to make it so that we can access just the data under the location we specified as opposed to the entire response that scrapy has found. It is worth noting that to run this command we must import the selector library from scrapy.Selector at the top of the page, with the line of code shown just below:\nfrom scrapy.selector import Selector\nFinally, we use the subset of the response to extract the movie titles for the actor. This process is shown in the final for loop. We call all elements in ‘tablePick.css(‘table.credit_group tr’)’ to access all of the tr classes individually, and then set the movOrTvName to the text under the class ‘role’ and within the ‘tooltip’ class and as the bdi attribute in the HTML file. Finally, we yield a dictionary with the actor name that we found in the beginning of the function, and the movie name that we just found. This will loop through all of the movies that the actor played a character in, resulting in all of their movies being represented in their own dictionaries to be saved in a .csv file we will create next.\ndef parse_actor_page(self, response):\n\n        '''\n        This function parses the actor page, extracting both the actor name and the movies/shows they were in, yielding the dictionaries with the actor name and the movies they appear in.\n        '''\n        \n        #extracts actor name from page\n        \n        actor_name = response.css('h2.title a::text').extract_first().strip()\n        \n        #list of data under actor acting appearances\n        \n        datCred = response.css('div.credits_list h3')\n        \n        #filtering to just acting roles\n        \n        for h3 in datCred:\n        \n            if 'Acting' in h3.xpath('./text()').get():\n            \n                txt = h3.xpath('following-sibling::table[1]').get()\n                \n                break\n                \n        #making tablePick a selector used to follow to movie data\n        \n        tablePick = Selector(text = txt)\n        \n        #extract and yield movie/show name with the actor name\n        \n        for cred in tablePick.css('table.credit_group tr'):\n        \n            movOrTvName = cred.css('td.role a.tooltip bdi::text').get().strip()\n            \n            yield{'actor': actor_name, 'movie_or_TV_name' : movOrTvName}\nNow that we have finished writing our spider, we are ready to run it in order to scrape our desired data off of the TMDB website. The first thing we need to do is go back into the settings.py file and comment out the page count limit we implemented just before creating our spider to allow our spider to scrape all of the pages it is sent to. We can now go back to the terminal and run the following command:\nscrapy crawl tmdb_spider -o results.csv -a subdir=671-harry-potter-and-the-philosopher-s-stone\nNote that the command is all one on the same line. This command will tell our spider to crawl on the website for the first Harry Potter movie as given by the subdirectory, and will write all of the results in a file named ‘results.csv’. If we go back into the project folder, we can open the file we just created and we will see dictionaries represented by a table with one column containing the actor names and the other column containing the titles of the movies that respective actor appeared in. This is where we will access the results our spider was able to produce. We can now use this data to create our recommendations.\nOur first step in creating our recommendations is importing our necessary packages and reading in the data we just acquired and saved into results.csv, which can be done via the following code:\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n#reading in the data we scraped using our spider\ndf = pd.read_csv('/Users/jakebrowning/Desktop/PIC16B/TMDB_scraper/results.csv')\n#using for loop to create a counting function for how many actors are in each movie\nmovDict = {}\nfor el in df1:\n    if el in movDict.keys():\n        movDict[el] = movDict[el]+1\n    else:\n        movDict[el] = 1\n\n#adjusting my dictionaries for the pandas dataframe\nsortedMovDict = sorted(movDict.items(), key=lambda x:x[1], reverse=True)\nconvertedMovDict = dict(sortedMovDict)\n\n#putting the counted dictionary into a pandas dataframe and displaying the dataframe\ndfList = pd.DataFrame(list(convertedMovDict.items()),columns=['Movie Name','Number of Shared Actors'])\ndfList\nWe can see this yields a list of movies containing shared actors, ordered from most shared actors to least shared actors with our original movie.\n\n\n#creating lists of the top twenty movies and their numbert of actors\nmovN = []\nnumAct = []\ni=0\nwhile i &lt; 20:\n    movN.append(dfList['Movie Name'][i])\n    numAct.append(dfList['Number of Shared Actors'][i])\n    i = 1+i\n\n#changing order of list to be better displayed in the graph\nmovN.reverse()\nnumAct.reverse()\n\n#creating bar chart with top twenty movie recommendations, displaying how many shared actors in each movie\nmyChart = plt.barh(movN, numAct)\nplt.bar_label(myChart, labels=numAct, label_type=\"edge\")\nplt.title('Top Twenty Movie Recommendations')\nplt.xlabel('Number of Shared Actors')\nplt.ylabel('Movie Title')\nplt.show()\nThis leaves us with our top twenty recommendations, shown in decreasing order by the bar chart displayed below."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "16bhwblog",
    "section": "",
    "text": "HW 4: Heat diffusion with Jax\n\n\n\n\n\n\nweek 6\n\n\n\n\n\n\n\n\n\nFeb 22, 2024\n\n\nJake Browning\n\n\n\n\n\n\n\n\n\n\n\n\nHomework 3: Flask\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nFeb 14, 2024\n\n\nJake Browning\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nFeb 11, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nAnalysis and Recommendations of Web Scraped Movie Data\n\n\n\n\n\n\nweek 6\n\n\n\n\n\n\n\n\n\nFeb 11, 2024\n\n\nJake Browning\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nFeb 8, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]